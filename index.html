<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">

  <title>Blog do Pedro</title>

  <!-- Bootstrap core CSS -->
  <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

  <!-- Custom styles for this template -->
  <link href="css/blog-home.css" rel="stylesheet">

</head>

<body>

  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
    <div class="container">
      <a class="navbar-brand" href="#">Blog do Pedro</a>
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarResponsive">
        <ul class="navbar-nav ml-auto">
          <li class="nav-item active">
              <span class="sr-only">(current)</span>
            </a>
          </li>
        </ul>
      </div>
    </div>
  </nav>

  <!-- Page Content -->
  <div class="container">

    <div class="row">

      <!-- Blog Entries Column -->
      <div class="col-md-8">

        <h1 class="my-4">Tecnologias Front end 
          <small>e Design</small>
        </h1>

        <!-- Blog Post -->
        <div class="card mb-4">
          <img class="card-img-top" src="https://media-exp1.licdn.com/dms/image/C4D16AQGWRe9R6RZAlg/profile-displaybackgroundimage-shrink_200_800/0?e=1596672000&v=beta&t=3DvJAr9xoAcnUWh_Bf4tUwDpWPXWpCI8pS1YvALJ0J0" alt="Card image cap">
          <div class="card-body">
            <h2 class="card-title">Post Create React App</h2>
            <p class="card-text">Create React App é um ambiente confortável para aprender React, e é a melhor maneira de começar um single-page application em React.</p>

             <p> Além de configurar seu ambiente de desenvolvimento para utilizar as funcionalidades mais recentes do JavaScript, ele fornece uma experiência de desenvolvimento agradável, e otimiza o seu app para produção.</p>
             <p> Será necessário ter Node >= 8.10 e npm >= 5.6 na sua máquina. Para criar um novo projeto, rode:</p>
              <p>npx create-react-app my-app</p>
              <p>cd my-app</p>
              <p>npm start</p>
          </div>
          <div class="card-footer text-muted">
            Posted on Juny 1, 2020 by
            <a href="#">Pedro Bazzo</a>
          </div>
        </div>

        <!-- Blog Post -->
        <div class="card mb-4">
          <img class="card-img-top" src="data:image/jpeg;base64,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" alt="Card image cap">
          <div class="card-body">
            <h2 class="card-title">Post Node.js CRUD</h2>
            <p class="card-text">Olá, dessa vez lhes trago um CRUD feito em Node. Se você não conhece NodeJS então vou fazer uma breve apresentação.
              NodeJS ou simplesmente Node, é um interpretador de Javascript open source e roda em todos sistemas operacionais. Ele é focado em migrar o Javascript do client-side para o server-side. Seu objetivo é ajudar programadores na criação de aplicações de alta escalabilidade, com códigos capazes de manipular dezenas de milhares de conexões simultâneas, numa única máquina física. O Node.js é baseado no interpretador V8 JavaScript Engine (interpretador de JavaScript open source implementado pelo Google em C++ e utilizado pelo Chrome). Foi criado por Ryan Dahl em 2009, e seu desenvolvimento é mantido pela fundação Node.js em parceria com a Linux Foundation.
              O conteúdo acima foi extraído do Wikipédia, e é um overview sobre a linguagem.
              Seguindo com o nosso conteúdo, iremos utilizar também o framework Express e o banco de dados NoSQL: MongoDB.
              Express: É um framework para construção de aplicações web para Node.js. Ele simplifica o processo de criação do servidor que já está disponível no Node.
              MongoDB: Será o nosso banco de dados, onde iremos armazenar os valores da nossa aplicação.
              CRUD: É um acrônimo para Create, Read, Update and Delete. É um conjunto de operações que temos para executar nos servidores (POST, GET, PUT e DELETE, respectivamente). Isto é o que cada operação faz:
              Criar (POST) - Insere um valor no nosso BD
              Ler (GET) - Seleciona um ou mais valores para exibir
              Atualizar (PUT) - Altera um valor em nosso BD
              Excluir (DELETE) - Remover um valor
              Para criarmos nossa aplicação, em primeiro lugar precisamos instalar a ferramenta.
              Para a instalação, você pode seguir esse tutorial.
              Bora colocar a mão na massa..
              Vamos iniciar nosso projeto, para tal, vamos abrir nosso terminal e criar uma pasta onde alocaremos nossos arquivos, depois entramos na pasta e via CLI abrimos o nosso editor de texto (escolha o seu favorito)
              Voltando ao terminal, vamos rodar o comando npm init. Esse comando cria o package.json, arquivo que irá nos ajudar a gerenciar as dependências que instalaremos mais tarde nesse tutorial.
              $ npm init 
              Agora iremos criar nosso arquivo principal, server.js
               console.log('Que a força esteja com você'
               Usando Express
Nós devemos instalar o Express antes de poder usá-lo em nosso app. Instalar o Express é bem simples, tudo que precisamos é rodar um código via CLI usando o gerenciador de pacotes NPM. Rode o código abaixo npm install express --save :
$ npm install express --save
Feito isso você verá que o npm salvou o Express como uma dependência no package.json.

Express salvo como dependência em package.json
Agora vamos usar o express no nosso arquivo server.js. Para isso vamos excluir o console.log() que tinhamos e colocar o código abaixo:

Precisamos fazer com que nosso servidor e o navegador possam se comunicar. Podemos fazer isso com a ajuda do método listen fornecido pelo Express:

Método para iniciar a comunicação com o servidor
Rodando no terminal o comando node server.js, vamos acessar o caminho localhost:3000 em nosso navegador. Você verá a mensagem a seguir:

Nosso navegador e servidor já estão se comunicando
Isso é um bom sinal. Isso significa que agora podemos nos comunicar com nosso servidor Express através do navegador. Na próxima etapa, irei explicar sobre os métodos GET e POST, também vamos conhecer o nodemon, e mais adiante a configuração do nosso banco de dados e os códigos para efetuarmos as operações do CRUD.
Acompanhe este tutorial, tentarei deixar o mais explicativo possível para auxiliar nos seus estudos. Se quiser deixar um comentário que possa acrescentar ao artigo, fique a vontade e não esqueça de compartilhar com seus amigos e deixe aquelas palminhas pra me incentivar.. rs’
Eu irei começar explicando a operação READ, pois é bem simples de entender o nosso cenário atual. Esta operação é executada pelos navegadores sempre que você visita uma página da web. Ao ser iniciado, os navegadores enviam uma solicitação GET ao servidor para executar uma operação de leitura. A razão pela qual vemos o erro “cannot get /” é porque ainda temos que enviar alguma informação de volta para o navegador, que esteja vindo do nosso servidor.
Usando Express, essa solicitação é feita com o método GET e pode ser escrito da seguinte maneira:

Exemplo do método GET
Note que incluímos em nosso arquivo server.js o trecho de código acima, veja que nele estamos passando o caminho no qual o navegador está acessando que em nosso caso é localhost:3000/, e para isso o primeiro argumento é “/”. O segundo argumento é uma função callback que informa ao servidor o que fazer quando o caminho é correspondido. Esse callback leva dois argumentos, um objeto de solicitação e outro de resposta (req e res, respectivamente). A fim de testarmos se está indo tudo ok, enviaremos somente a frase ‘Hello Word’ com o método send para nos trazer o objeto de resposta. Note que estou usando o padrão ES6, e por isso usei diretamente uma arrow function.
Agora vamos reiniciar nosso servidor, basta fazer o seguinte:
Pare o servidor atual pressionando CTRL + C no seu terminal.
Rode novamente o comando node server.js .
Em seguida, acesse localhost:3000 no seu navegador. Você deve estar vendo uma string que diz: Hello World.

Comunicação entre nosso servidor e navegador
Ótimo Vamos agora iniciar a parte visual do nosso projeto, para isso irei utilizar um template engine chamado EJS (Embedded Javascript), ele é bem simples de usar principalmente para quem tem familiaridade com HTML e Javascript. Para instalar o ejs, basta digitar no seu terminal:
npm install ejs --save
Precisamos configurar nossa view engine no Express,basta incluir o trecho de código abaixo.

Feito isso, poderemos gerar código HTML que será renderizado em nosso navegador. Vamos então criar nosso arquivo index.ejs dentro de uma pasta chamada ‘views’, veja como ficará nossa estrutura:

Vamos incluir algum conteúdo nesse arquivo.

Agora precisamos setar nosso arquivo para que ele seja enviado pro servidor, e ser renderizado no navegador. Para isso precisamos fazer uma alteração no trecho de código app.get(). Veja abaixo a alteração:

Substituí o método res.send(), por res.render()
Certo, agora precisamos reiniciar nosso servidor, para visualizar a alteração em nosso navegador. Vá ao seu terminal e pressione CTRL + C , em seguida digite novamente node server.js . Agora atualizando a página no seu navegador você terá esse resultado:

Conteúdo renderizado pelo navegador
Você deve ter percebido que toda alteração que fazemos no server.js, nós precisamos parar o servidor e iniciar novamente pelo terminal. É uma tarefa simples, mas bem chatinha, pensando em agilidade e desempenho, iremos utilizar um pacote que nos auxiliará nessa tarefa.
Lhes apresento o Nodemon.
O Nodemon reinicia o servidor automaticamente sempre que você salva um arquivo que o servidor usa. Podemos instalar o Nodemon usando o seguinte comando:
npm install nodemon --save-dev
Note que estamos usando uma sinalização --save-dev aqui porque estamos usando apenas o Nodemon quando estamos desenvolvendo. Esse sinalizador salva o Nodemon como uma devDependency no nosso arquivo package.json. O Nodemon se comporta exatamente como o Node, o que significa que podemos executar nosso servidor chamando nodemon server.js. No entanto, não podemos fazer isso na linha de comando agora porque o Nodemon não está instalado com um sinalizador -g. Há outra maneira simples de executar o Nodemon, podemos criar um scriptdentro do package.json.

Script para o nodemon
Agora, você pode executar o npm run dev para acionar o nodemon server.js.

Servidor iniciado pelo nodemon
CRUD — CREATE
A operação CREATE é executada apenas pelo navegador se uma solicitação POST for enviada ao servidor. Essa solicitação POST pode ser acionada com JavaScript ou por meio de um elemento <form>
Vamos descobrir como usar um elemento <form> para criar novas entradas para o nosso projeto nesta parte do tutorial. Para fazer isso, iremos utilizar o form já criado em nosso arquivo index.ejs.
Você precisa ter três coisas neste elemento de formulário:
Um atributo action .
Um atributo method .
E um atributo name para todo elemento do formulário.

Parte do nosso arquivo index.ejs
O atributo action informa ao navegador para onde redirecionar nosso app Express. Nesse caso estamos sendo direcionados para /show . O atributo method informa ao navegador qual solicitação enviar, nesse caso é uma solicitação do tipo POST.
Em nosso servidor, podemos processar essa solicitação POST com um método post fornecido pelo Express que leva os mesmos argumentos do método GET:

Após isso, salve as alterações. Note que em seu terminal o nodemon irá reiniciar o servidor automáticamente, então vá no seu navegador e preencha o formulário e clique em enviar. Você poderá ver em seu terminal a seguinte mensagem:

Servidor reiniciado automaticamente + mensagem no console
Ótimo, sabemos que o Express está lidando direitinho com o formulário. Mas pergunta que fica é: como obtemos os valores de entrada com o Express?
Acontece que o Express não lida com a leitura de dados do elemento <form> por conta própria. Temos que adicionar outro pacote chamado body-parser para conseguir essa funcionalidade, pare o servidor e digite em seu terminal:
npm install body-parser --save 
O Express nos permite adicionar middleware como body-parser ao nosso aplicativo com o método use. Você ouvirá muito o termo middleware ao lidar com o Express, eles são basicamente plugins que alteram o objeto request ou response antes de serem manipulados pelo nosso aplicativo.

Inclua bodyParser em seu arquivo server.js
O método urlencoded dentro de body-parser diz ao body-parser para extrair dados do elemento <form> e adicioná-los à propriedade body no objeto request. Faça o teste, dê um console.loge preencha o formulário, você deverá ver tudo no campo de formulário dentro do objeto:

Função console.log()
Você verá em seu terminal algo parecido com isto:

Bom, por enquanto é isso. Na próxima parte vamos fazer a conexão com nosso banco de dados e iniciar as operações do CRUD.
Espero que estejam gostando e principalmente aprendendo com este conteúdo. Não esqueçam de compartilhar, quem sabe esse conteúdo não ajuda aquele seu amigo também..

Voltamos para nossa terceira e última parte desse CRUD, essa parte será um pouco mais extensa que as anteriores. Creio que todos estejam animados para finalizar esse projeto, então vamos nessa..
(Caso ainda não tenha visto as partes anteriores: Parte 1/Parte 2)
Ps. Desculpem a demora, mas infelizmente ocorreram alguns imprevistos e não pude finalizar antes.. mas vamos direto ao que importa.. kkkk’
MongoDB
Para usarmos o MongoDB como banco de dados, nós precisamos instalá-lo e podemos fazer isso através do npm conforme abaixo.
npm install mongodb --save 
Uma vez instalado, podemos nos conectar ao MongoDB através do método de conexão do Mongo.Client, conforme mostrado no código abaixo:
const MongoClient = require('mongodb').MongoClient 
const uri = "<!-- insira aqui o caminho para seu BD -->"
MongoClient.connect(uri, (err, client) => {
  // ... start the server
})
O código acima será implementado mais adiante. Para este tutorial, irei utilizar o mLab, crie uma conta no site deles, é fácil e grátis. Após verificar sua conta, você pode criar um novo Deployment, selecione a opção sandbox, em seguida coloque o nome do seu banco de dados.

Quando terminar de implementar, entre na aba ‘Users’ e crie um usuário e uma senha para o banco de dados, você vai usar esses dados para conectar ao banco que você acabou de criar.

Finalmente, pegue o url do MongoDB e adicione-o ao seu método MongoClient.connect. Certifique-se de usar seu usuário e senha do banco de dados!

Em seguida, queremos iniciar nosso servidor apenas quando o banco de dados estiver conectado. Por isso, vamos mover o app.listen para o método connect. Lembra daquele código de conexão, logo no início deste post? Vamos implementá-lo agora.

Certifique-se de alterar o usuário e senha com os seus dados(<dbuser>:<dbpassword>)
Acabamos de configurar o MongoDB. Agora, vamos criar uma coleção para armazenar os dados do nosso projeto. A propósito, uma coleção é um local nomeado para armazenar objetos, você pode criar quantas coleções quiser. Podem armazenar objetos como “nomes”, “produtos”, ou qualquer outro nomenclatura que você escolher. Vamos iniciar as operações do CRUD.
Salvando nossos dados no banco.
Iremos criar a coleção “data”, que irá armazenar nossos dados, apenas colocando-a entre aspas ao chamar o método db.collection() do MongoDB. Ao criar a coleção, também podemos salvar nossa primeira entrada no MongoDB com o método save simultaneamente.
Quando terminarmos de salvar, precisamos redirecionar o usuário para algum lugar (senão o usuário ficará esperando para sempre até que nosso servidor seja alterado). Nesse caso, vamos redirecioná-los de volta para /, o que faz com que os navegadores sejam recarregados.

Agora, se você inserir algo no elemento <form>, poderá ver uma entrada na sua coleção do MongoDB e a confirmação através do seu terminal.

Nossos objetos da coleção

Confirmação de dados salvo em nosso BD
Obaa, já temos algum conteúdo na coleção, por que não tentar mostrar ao usuário quando eles chegarem à nossa página?
CRUD — READ
Mostrando o conteúdo de nossa coleção.
Temos que fazer algumas coisas para mostrar o conteúdo armazenado em nosso banco de dados para o nosso usuário. Precisamos:
Pegar o conteúdo no banco de dados.
Usar nossa template engine para exibir esse conteúdo.
Well, let’s go in baby steps..
Podemos obter o conteúdo do nosso BD usando o método find disponível no método collection.

O método de localização retorna um cursor(um objeto do Mongo), este objeto contém todas as citações de nosso banco de dados. Ele também contém várias outras propriedades e métodos que nos permitem trabalhar com dados facilmente. Um desses métodos é o método toArray.
O método toArray recebe uma função callback que nos permite fazer algumas coisas com os objetos que recuperamos do mLab. Vamos tentar fazer um console.log() nesses resultados e ver o que conseguimos!

Incluímos o trecho de código em destaque
Após incluir o trecho acima, vá até seu navegador e preencha o <form> e clique em submit . Você verá o resultado em seu terminal.

Conteúdo que preenchemos em nosso <form>
Ótimo! Você está vendo o conteúdo preenchido (o mesmo que foi salvo no banco de dados). Concluímos a primeira parte, que é obter dados do MongoLab. A próxima parte será renderizar esse conteúdo usando nossa template engine. Bom, para isso crie um novo arquivo dentro da pasta ‘views’ conforme abaixo:

Crie o arquivo show.ejs
Agora abra-o e crie uma tabela que mostre o conteúdo que enviamos pelo formulário.

Conteúdo do arquivo show.ejs
Note que na linha 18 nós estamos mostrando nossa variável data combinada com o método .forEach() onde irá percorrer o conteúdo da collection em nosso banco de dados, e criamos então a function(details) que nas linhas 20 e 21, irá mostrar o conteúdo que estamos chamando com <%= details.name%> e <%= details.surname%> respectivamente.
Em seguida vamos fazer uma pequena alteração no nosso server.js. Vamos deixá-lo conforme abaixo.

Conteúdo de nosso arquivo server.js
Volte ao navegador e preencha o formulário, você será redirecionado para a página localhost:3000/show , e verá o conteúdo abaixo(provavelmente seu conteúdo será diferente.. rs’).

Nosso conteúdo enviado pelo <form>
CRUD — UPDATE
Atualizando dados.
A operação UPDATE é usada quando você quer alterar algum conteúdo no BD, não irei entrar em detalhes sobre o protocolo HTTP, irei abordar como funciona essa requisição em outro artigo.
Note que incluí os buttons no arquivo show.ejs onde irá direcionar para a página de edit, e incluí também o de delete, o qual será nossa próxima etapa do CRUD.

Código da view show.ejs.

View renderizada com os botões.
Para nosso projeto, irei fazer um post na rota /edit/:id e irei tratar essa atualização conforme abaixo. Note que fiz algumas alterações na estrutura do projeto, aproveitando um recurso de rotas que o Express() nos oferece.
Veja abaixo que, com o recurso de rotas fornecido, podemos apenas indicar qual a rota iremos observar e dentro dessa rota, teremos os métodos abaixo.

Método update dentro de server.js.
No método.get, estou armazenando em var id, o id que iremos passar no params vindo da view (faremos primeiro nossos métodos no servidor, e depois a view), estou usando essa variável para encontrar o objeto que iremos alterar, isso está sendo feito na função .find(Object(id)) que irá percorrer o array em nosso banco, e quando encontrar o nosso objeto, irá renderizar a nossa view edit.ejs e também passando o resultado desse objeto para ser usado com os valores dentro do <form> em nossa view.

edit.ejs
Na imagem ao lado, vemos o código da nossa view, criei um novo arquivo dentro da pasta views, com o nomeedit.ejs. Nele há um formulário parecido com o que temos no index.ejs, porém, ao invés de incluir um novo “nome” e “sobrenome”, iremos alterar o valor já existente. Note que incluí um botão para voltar aos registros salvos, e outro que fará o post para editar nosso objeto, veja que já estou importando os dados que está sendo renderizado conforme imagem acima(ou ao lado, como preferir.. kkkk). Note também que estou passando o id do objeto no params, e já estou usando os valores da nossa base de dados dentro do input para melhor visualização do dado que estamos editando.

View renderizada.
Voltando ao nosso código de update pouco mais acima, note que quando fazemos um .post o nosso server irá armazenar as variáveis que iremos usar para dar update em nosso objeto, updateOne() recebe o nosso objeto que estamos alterando, e $set recebe os dados do form que queremos atualizar, se tudo estiver correto, seremos redirecionado para a tela onde mostra todos nossos registros, e estamos printando em nosso console a informação de “Atualizado no banco de dados”.

console.log(“Atualizado no Banco de Dados”)

Registro alterado.
Feito as alterações em nossas views, e com o método update sendo tratado corretamente, damos sequência no nosso CRUD.
CRUD — DELETE
Deletando dados.
A operação DELETE é a última operação desse nosso projeto, após ter feito corretamente o UPDATE, e tendo adquirido esse conhecimento, você verá que o método .delete é bem simples. Novamente não irei entrar em méritos de requisições HTTP, tratarei essa operação de forma simplificada.
Lembra que fizemos o botão de “Deletar” em nossa página /show? Pois é, já estamos enviando o id que iremos apagar do nosso BD, então será simples fazer esse tratamento.

Operação DELETE

Tela de Registros.

console.log()

Objeto deletado!
Note que quando clicar no botão de deletar, seremos direcionados para /delete/:id e então, com o método .get iremos pegar e armazenar o id enviado, e da mesma forma que o updateOne, estamos passsando o id a ser buscado em nosso BD e então deletá-lo, printamos em nosso console a informação de deletado e seremos redirecionados para a tela de registros.
Feito isso, encerramos nosso projeto de CRUD Simples em NodeJS.
Essa última parte do projeto se extendeu bastante, e também demorou demais para sair.. Novamente peço desculpas, mas não pude continuar e lançar essa parte anteriormente.

<p>Fonte: https://medium.com/baixada-nerd/criando-um-crud-completo-com-nodejs-express-e-mongodb-parte-3-3-b243d14a403c</p>
              </p>
          </div>
          <div class="card-footer text-muted">
            Posted on Juny 1, 2020 by
            <a href="#">Pedro Bazzo</a>
          </div>
        </div>

        <!-- Blog Post -->
        <div class="card mb-4">
          <img class="card-img-top" src="https://i1.wp.com/blog.logrocket.com/wp-content/uploads/2020/05/deno-1-0-what-you-need-to-know-1.png?w=730&ssl=1" alt="Card image cap">
          <div class="card-body">
            <h2 class="card-title">Post: Um pouco sobre o Deno.js</h2>
            <p class="card-text">Depois de quase dois anos, a espera está quase no fim. A API foi congelada e a contagem regressiva para o Deno 1.0, oficialmente agendada para lançamento em 13 de maio, começou.

              Devido ao seu famoso criador e visão de futuro, Deno certamente será o lançamento mais emocionante e controverso relacionado ao JavaScript da memória recente.
              
              Deno é um ambiente de programação JavaScript / TypeScript de uso geral. Ele reúne muitas das melhores tecnologias de código aberto e oferece uma solução abrangente em um pequeno arquivo executável.
              
              Criado por Ryan Dahl, mais conhecido como o cérebro por trás do Node.js , o Deno aproveita os recursos de JavaScript que estão disponíveis desde o lançamento do Node.js. em 2009. Ele também aborda as falhas de design que Ryan mencionou em seus “ 10 Palestra de coisas que me arrependo do Node.js. ” Alguns a chamam de sequência do Node.js, embora o próprio autor não faça tal afirmação.
              
              Diferentemente do Node.js, que foi escrito em C ++, o Deno é escrito em Rust. Ele é construído sobre a plataforma Tokio e, como o Node.js, executa o JavaScript usando o mecanismo V8. Um recurso notável é que o TypeScript está embutido. Embora ele ainda precise compilar o JavaScript para ser executado, ele é feito internamente, para que o TypeScript se comporte ao usuário como se tivesse suporte nativo.
              
              Começando
              Para baixar o Deno, siga as instruções na página inicial . Para atualizar para versões futuras, use deno upgrade.
              
              Para obter ajuda sobre qualquer subcomando Deno, use um dos seguintes.
              
              deno [subcommand] -h para um resumo
              deno [subcommand] --help para mais detalhes
              Neste guia, abordaremos todos os recursos matadores que o Deno 1.0 tem a oferecer e forneceremos exemplos de como usá-los com a sintaxe mais recente. Usarei o TypeScript sempre que possível, mas o equivalente em JavaScript deve ser óbvio.
              
              Estou convencido de que você se apaixonará por Deno quando terminarmos. Este guia deve fornecer tudo o que você precisa para começar.
              
              Segurança
              Deno é seguro por padrão. Por comparação, o Node.js tem acesso total ao seu sistema de arquivos e rede.
              
              Para executar um programa sem permissões, use:
              
              deno arquivo run - precisando - de - run - um - subprocesso . ts
              Se o código precisar de uma configuração de permissão, você será alertado.
              
              error : Uncaught PermissionDenied : acesso para executar um subprocesso , execute novamente com o sinalizador - allow - run  
              Deno usa opções de linha de comando para permitir explicitamente o acesso a diferentes partes do sistema. Os mais usados ​​incluem:
              
              acesso ao ambiente
              acesso à rede
              acesso de leitura / gravação do sistema de arquivos
              executando um subprocesso
              Para ver uma lista completa de permissões com exemplos, digite .deno run -h
              
              É uma prática recomendada usar listas brancas de permissão para read, writee net. Isso permite que você seja ainda mais específico sobre o que Deno tem permissão para acessar. Por exemplo, para permitir ao Deno arquivos somente leitura no diretório, use:/etc
              
              deno  - permite - lê = / etc
              Atalhos para usar permissões
              Em breve, você poderá se cansar de ativar explicitamente permissões sempre que executar seu aplicativo. Para contornar isso, você pode seguir qualquer uma das seguintes abordagens.
              
              1. Permitir todas as permissões
              Você pode ativar todas as permissões usando ou seu atalho . Isso não é recomendado porque remove a vantagem de segurança de ter permissões específicas.--allow-all-A
              
              2. Faça um script bash
              Crie um script bash com a quantidade mínima de permissões necessárias para executar o programa.
              
              #! / bin / bash // Permitir subprocessos em execução e acesso de gravação no sistema de arquivos 
              deno run - allow - run - allow - write mod . ts
              
              A desvantagem aqui é que você provavelmente precisará de alguns deles para executar, testar e agrupar.
              
              3. Use um corredor de tarefas
              Você pode usar a ferramenta GNU makepara criar um arquivo com um conjunto de comandos Deno, completos com permissões. Você também pode usar a versão específica do Deno, Drake .
              
              4. Instale um programa executável do Deno
              Use deno installpara instalar um programa Deno completo com todas as permissões necessárias para executar. Uma vez instalado, você pode acessar o programa de qualquer lugar do $PATH.
              
              A biblioteca padrão
              A biblioteca padrão do Deno é uma coleção de módulos comumente usados, mantidos pelo projeto Deno e garantidos para trabalhar com o Deno. Ele cobre o código que os usuários mais frequentemente precisam para tarefas comuns e se baseia livremente na biblioteca padrão fornecida pela linguagem de programação Go.
              
              O JavaScript sempre foi atormentado por sua falta de uma biblioteca padrão. Os usuários foram forçados a reinventar a roda de novo e de novo, e os desenvolvedores frequentemente devem procurar na NPM módulos de terceiros para resolver problemas comuns que os fabricantes da plataforma devem fornecer.
              
              Pacotes de terceiros para problemas complexos resolvidos por bibliotecas como o React são uma coisa boa, mas para coisas simples, como a geração de UUID , é muito melhor usar uma biblioteca padrão oficial. Essas pequenas bibliotecas podem servir como blocos de construção para bibliotecas maiores, tornando o desenvolvimento mais rápido e menos indutor de ansiedade. Quantas vezes uma biblioteca outrora popular foi abandonada, deixando o usuário para mantê-la ou encontrar uma nova? De fato, entre 10 e 20% dos pacotes OSS comumente usados não são mantidos ativamente .
              
              Módulos disponíveis e seus equivalentes npm
              Módulo Deno	Descrição	altitude Equivalentes
              cores	Adiciona cor ao terminal	giz, cores e cores
              data hora	Ajuda a trabalhar com o Dateobjeto JavaScript	
              codificação	Adiciona suporte para estruturas de dados externas como base32, binário, csv, toml e yaml	
              bandeiras	Ajuda a trabalhar com argumentos de linha de comando	minimista
              fs	Ajuda na manipulação do sistema de arquivos	
              http	Permite veicular arquivos locais por HTTP	servidor http
              registro	Usado para criar logs	Winston
              teste	Para afirmação de teste de unidade e benchmarking	chai
              uuid	Geração UUID	uuid
              ws	Ajuda na criação de cliente / servidor WebSocket	ws
              Texto datilografado é incorporado ao Deno
              TypeScript LogoTypeScript é JavaScript, mas com tipos explícitos adicionados. Qualquer JavaScript válido também é TypeScript válido, portanto, converter seu código em TypeScript é fácil. Basta alterar a extensão e começar a adicionar os tipos..ts
              
              Para usar o TypeScript no Deno, não há nada que você precise fazer. Sem o Deno, o TypeScript precisa ser compilado no JavaScript para ser executado. O Deno faz isso internamente para você, tornando o TypeScript ainda mais fácil de adotar.
              
              Usando seu próprio tsconfig.json
              Para aqueles familiarizados com o TypeScript, você estará acostumado a ter um arquivo para fornecer as opções do compilador. Isso é opcional quando você está usando o Deno, porque ele já possui sua própria configuração padrão. Se você usar o seu próprio e entrar em conflito com o Deno, você será alertado.tsconfig.jsontsconfig.json
              
              Este recurso requer a opção e seu .-ctsconfig.json
              
              deno  run  - c  tsconfig . json  [ arquivo - a - run . ts ]
              Se você é como a maioria dos desenvolvedores, ficará muito feliz ao saber que o Deno usa o strictmodo por padrão. A menos que algum mal-intencionado o substitua, o Deno justificadamente alertará o usuário sobre o máximo possível de práticas de codificação desleixadas.
              
              Deno usa padrões da web sempre que possível
              w3 LogoDemora muito tempo para criar um padrão da Web e, uma vez definido, não é aconselhável ignorá-lo. Enquanto as estruturas vêm e vão, os padrões da web permanecerão. O tempo gasto investindo no aprendizado de uma API padronizada nunca é desperdiçado porque ninguém ousa quebrar a Web; pode ser usado por décadas, talvez até o resto de sua carreira.
              
              A fetchAPI da web fornece uma interface para buscar recursos. Existe um método JavaScript disponível no navegador. Se você deseja usar esse padrão no Node.js, precisará acessar a biblioteca de terceiros Node Fetch . No Deno, ele é incorporado e funciona exatamente como a versão do navegador, imediatamente.fetch()
              
              O Deno 1.0 fornece as seguintes APIs compatíveis com a web.
              
              addEventListener
              atob
              btoa
              clearInterval
              clearTimeout
              dispatchEvent
              fetch
              queueMicrotask
              removeEventListener
              setInterval
              setTimeout
              AbortSignal
              Blob
              File
              FormData
              Headers
              ReadableStream
              Request
              Response
              URL
              URLSearchParams
              console
              isConsoleInstance
              location
              onload
              onunload
              self
              window
              AbortController
              CustomEvent
              DOMException
              ErrorEvent
              Event
              EventTarget
              MessageEvent
              TextDecoder
              TextEncoder
              Worker
              ImportMeta
              Location
              Todos estão disponíveis no escopo de nível superior do seu programa. Isso significa que, se você evitar usar qualquer método no espaço para nome, seu código deverá ser compatível com o Deno e o navegador. Embora nem todas essas APIs do Deno sejam 100% compatíveis com suas especificações da Web equivalentes, esse ainda é um bônus enorme para os desenvolvedores de front-end.Deno()
              
              Módulos ECMAScript
              Uma das principais mudanças no Deno no Node.js. é que o Deno usa o padrão oficial do módulo ECMAScript em vez do CommonJS herdado. O Node.js levou até o final de 2019 para habilitar os módulos ECMAScript com a versão 13.2.0, mas mesmo assim o suporte foi incompleto e ainda incluía a controversa extensão de arquivo..mjs
              
              O Deno se liberta do passado usando modernos padrões da web para seu sistema de módulos. O módulo é referenciado usando um URL ou caminho de arquivo e inclui uma extensão de arquivo obrigatória. Por exemplo:
              
              import * como log de "https://deno.land/std/log/mod.ts" ; import { outputToConsole } de "./view.ts" ;   
                 
              O problema com o uso de extensões de arquivo
              Deno espera que os módulos tenham extensões de arquivo, mas o TypeScript não.
              
              Problema de extensão TypeScript
              Usar uma extensão de arquivo em qualquer lugar é lógico e parece o caminho óbvio. Na realidade, infelizmente, as coisas são mais complexas do que isso. Por enquanto, você pode usar a Extensão de Código do Visual Studio para resolver isso em projetos somente de Deno.
              
              O problema parece controverso para os criadores do TypeScript. Até que finalmente possamos abandonar o CommonJS, não vejo uma solução rápida e fácil.
              
              Vamos tirar um momento para orar aos deuses sábios e antigos da programação. Deixe-os atacar esses formatos legados e punir aqueles que os mantêm em detrimento de todos nós.
              
              Gerenciamento de pacotes
              Cachorro sentado na frente de caixas de papelãoHouve um repensar radical sobre o funcionamento do gerenciamento de pacotes no Deno. Em vez de depender de um repositório central, ele é descentralizado. Qualquer pessoa pode hospedar um pacote, assim como qualquer pessoa pode hospedar qualquer tipo de arquivo na web.
              
              Existem vantagens e desvantagens em usar um repositório centralizado como o npm, e esse aspecto do Deno certamente será o mais controverso.
              
              Como o novo gerenciamento de pacotes da Deno funciona
              É tão radicalmente simplificado que pode chocá-lo.
              
              import { assertEquals } de "https://deno.land/std/testing/asserts.ts" ;   
              Vamos detalhar as mudanças.
              
              Não há mais gerenciador de pacotes centralizado. Você importa módulos ECMAScript diretamente da web
              Não há mais resolução "mágica" do módulo Node.js. Agora, a sintaxe é explícita, o que facilita muito as coisas de raciocinar sobre
              Não há mais node_modulesdiretório. Em vez disso, as dependências são baixadas e ocultadas no disco rígido, fora da vista. Se você deseja atualizar o cache e baixá-los novamente, basta adicionar ao seu comando--reload
              Se você deseja baixar dependências juntamente com o código do projeto, em vez de usar um cache global, use a $DENO_DIRvariável env.
              
              Localizando bibliotecas de terceiros compatíveis
              Há uma área de usuário para módulos de terceiros compatíveis com o Deno, mas a navegação é muito básica no momento da escrita. Por exemplo, não há facilidade para pesquisar por popularidade ou número de downloads. Prevejo que a área do usuário será expandida ou outros sites alternativos serão criados para os módulos contribuídos.
              
              Embora não haja suporte oficial para compatibilidade com versões anteriores do Node.js., ainda existem muitas bibliotecas e aplicativos disponíveis que funcionarão bem com o Deno. Alguns sairão da caixa, enquanto outros exigem um pouco de esforço para começar a trabalhar.
              
              Tipo de biblioteca	Compatibilidade
              Executa no navegador
              Usa sintaxe do ESM
              Confirme a compatibilidade com o catálogo de pacotes Pika e use o NPM ou o CDN da Pika
              Executa no navegador
              Usa a sintaxe CommonJS
              Use jspm.io para agrupar módulos na sintaxe do ESM ou na CDN do Pika
              Não roda no navegador
              Não usa APIs do Node.js.
              Use jspm.io para agrupar módulos na sintaxe do ESM ou na CDN do Pika
              Usa APIs do Node.js.
              Provavelmente isso não vai funcionar, mas tente a camada de compatibilidade oficial da biblioteca padrão do NodeJS
              Instalando Módulos de Terceiros
              Deno ainda é muito novo e o ecossistema circundante ainda está se formando. No momento da redação, recomendo o Pika como o primeiro local para começar a procurar módulos compatíveis, depois das bibliotecas padrão e de usuário. Qualquer pacote disponível no NPM também deve estar no CDN do Pika e foi convertido automaticamente para trabalhar import.
              
              Os desenvolvedores por trás do Pika trabalharam com o Deno para fornecer tipos TypeScript via módulos ECMAScript chamados X-TypeScript-Types . Você pode tirar vantagem disso simplesmente usando a plataforma CDN.
              
              Indo além Package.Json
              A maior parte do ecossistema JavaScript ainda gira em torno do uso . Foi inchado para incluir muitas responsabilidades, tais como:package.json
              
              Mantendo metadados sobre o projeto
              Listando dependências do projeto com controle de versão
              Categorizando dependências como dependenciesoudevDependencies
              Definindo o ponto de entrada do programa
              Armazenando scripts de shell relacionados ao projeto
              Definindo uma categoria de tipo, introduzida recentemente para melhorar o suporte ao módulo ECMAScript
              { "name" : "Nome do Projeto" , // metadados "version" : "1.0.0" , // metadados "description" : "Meu aplicativo" , // metadados "type" : "module" , // module module "main" : "src / mod.ts" , // funcionalidade do módulo "scripts" : { "build" : "npm execute _copy-build-files && rollup -c" , "build-watch" : "npm execute _copy-build-files && rollup -cw " }, // funcionalidade de script " license " :
                  
                  
                  
                  
                  
                 
                   
                   
                 
                 "gpl-3.0" , // metadados "devDependencies" : { "@ rollup / plugin-typescript" : "^ 3.1.1" , "rollup" : "^ 1.32.1" , "typescript" : "^ 3.8.3 " }, // funcionalidade de versionamento e categorização " dependências " : { " tplant " : " ^ 2.3.3 " } // funcionalidade de versionamento e categorização } 
                 
                   
                   
                   
                 
                 
                   
                 
              Todas essas práticas se reuniram ao longo do tempo e agora representam a maneira padrão pela qual o ecossistema JavaScript funciona. É fácil esquecer que esse não é um padrão oficial; só foi conjurado quando esses recursos se tornaram uma necessidade. Agora que o JavaScript alcançou, é hora de uma grande repensar.
              
              O Deno ainda não pode substituir todas as funcionalidades do , mas existem algumas soluções atuais.package.json
              
              Usando e URLs para controle de versãodeps.ts
              Há uma convenção Deno para controle de versão de pacotes, que é usar um arquivo especial chamado . No interior, as dependências são reexportadas. Isso permite que diferentes módulos no aplicativo se refiram à mesma fonte.deps.ts
              
              Em vez de informar ao npm qual versão de um módulo baixar, ela é referenciada no URL em .deps.ts
              
              exportar { assert } de "https://deno.land/std@v0.39.0/testing/asserts.ts" ; exportar { verde , negrito } de "https://deno.land/std@v0.39.0/fmt/colors.ts" ;     
                 
              Se você deseja atualizar algum módulo, pode alterar os URLs . Por exemplo, substitua por e a nova versão será usada em qualquer lugar. Se, em vez disso, você importou diretamente para cada módulo, teria que percorrer minuciosamente o aplicativo inteiro e alterar cada referência.deps.ts@v0.39.0@v0.41.0https://deno.land/std@v0.39.0/fmt/colors.ts
              
              Seria um risco de segurança supor que um módulo que você baixou antes não poderia ter sido violado posteriormente. É por isso que também há uma opção para criar um arquivo de bloqueio . Isso garantirá que o módulo recém-baixado seja idêntico ao que você baixou originalmente.
              
              deno doc e usando JSDoc para metadados
              O JSDoc foi lançado em 1999, há 21 anos. Agora é a maneira mais usada e suportada de documentar JavaScript e TypeScript. Embora não seja um padrão oficial da Web, é um substituto perfeito para todos os metadados no seu .package.json
              
              /**
               * @file Gerencia as definições de configuração do widget
               * @autor Lucio Fulci
               * @copyright 2020 Intervision
               * @license gpl-3.0
               * @version 1.0
               *
              O Deno suporta o JSDoc imediatamente e o usa em seu sistema de documentação integrado. Embora atualmente não use os metadados acima, o comando deno doclê a descrição de uma função e as descrições de seus parâmetros.
              
              /**
               * Retorna um valor de (true?) Se a regra deve ser incluída
               *
               * chave @param Nome da chave atual da regra que está sendo verificada
               * @param val Valor atual da regra que está sendo verificada
               **/
              Você pode usar para ver a documentação do seu programa.deno doc <filename>
              
              Doc Mod Deno . Ts
              
              função rulesToRemove ( -chave : corda , val : qualquer [] ): boolean Retorna um valor de se a regra é para ser incluído   
                  
              Quando seu programa estiver hospedado online, use o visualizador de documentação online para vê-lo em mais detalhes.
              
              Ferramentas integradas da Deno
              Mulher gritando rodeada por logotipos de software
              Essa é a área que terá maior impacto nos desenvolvedores de front-end. O estado atual das ferramentas JavaScript é um caos avassalador. Quando você adiciona ferramentas TypeScript, a complexidade aumenta ainda mais.
              
              Uma das melhores coisas do JavaScript é que ele não requer compilação, para que possa ser executado imediatamente no navegador. Isso torna muito fácil obter feedback sobre sua codificação imediatamente. Existe uma barreira muito baixa à entrada; tudo o que você precisa para escrever um software é um editor de texto e um navegador.
              
              Infelizmente, essa simplicidade e acessibilidade foram prejudicadas pelo que poderia ser descrito como um culto ao excesso de ferramentas. Ele transformou o desenvolvimento JavaScript em um pesadelo de complexidade. Eu até vi um curso inteiro dedicado à configuração do Webpack. Essa bobagem precisa terminar - a vida é muito curta.
              
              O caos das ferramentas cresceu a tal ponto que muitos desenvolvedores estão desesperados para voltar a escrever código, em vez de brincar com arquivos de configuração e agonizar sobre qual dos vários padrões concorrentes eles devem adotar. Um projeto emergente que trata disso é a Roma do Facebook . No momento da redação deste texto, isso está em sua infância. Embora possa ser benéfico, o Deno tem o potencial de ser uma solução muito mais substancial.
              
              O Deno é um ecossistema inteiro em si, completo com tempo de execução e seu próprio sistema de gerenciamento de módulos / pacotes. Isso fornece um escopo muito maior para que todas as suas próprias ferramentas sejam incorporadas. Vamos examinar quais ferramentas estão disponíveis na 1.0 e como você pode usá-las para reduzir a dependência de bibliotecas de terceiros e simplificar o desenvolvimento.
              
              Ainda não é possível substituir um pipeline de construção de front-end inteiro em Deno, mas não demorará muito até que você possa.
              
              Teste
              O corredor de teste é incorporado ao núcleo do Deno usando a função A biblioteca de asserções é fornecida na biblioteca padrão. Todos os seus favoritos, como e , estão incluídos, juntamente com algumas afirmações menos comuns, como .Deno.test()assertEquals()assertStrictEq()assertThrowsAsync()
              
              No momento da redação deste artigo, não há recurso de cobertura de teste, e o modo de exibição precisa ser configurado usando ferramentas de terceiros, como Denon .
              
              Para ver todas as opções do executor de teste, use . Embora sejam bastante limitados, há muitos recursos com os quais você pode estar familiarizado em programas como o Mocha. Por exemplo, irá parar no primeiro erro encontrado e pode ser usado para filtrar quais testes executar.deno test --help--failfast--filter
              
              Usando o executor de teste
              A sintaxe mais básica é deno test. Isto irá executar todos os arquivos no diretório de trabalho que terminam em _testou com a extensão , , , ou (por exemplo, ).test.js.ts.jsx.tsxexample_test.ts
              
              import { assertEquals } de "https://deno.land/std/testing/asserts.ts" ;   
              
              Deno . teste ({ nome : "exemplo de teste" , 
                fn (): void { 
                  assertEquals ( "mundo" , "mundo" )); 
                  assertEquals ({ olá : "mundo" }, { olá : "mundo" }); }, }) ;
                           
                
              Se seu código usa o DOM, você terá que fornecer seu próprio com . Entraremos em mais detalhes abaixo.tsconfig.jsonlib: ["dom", "esnext"]
              
              Formatação
              A formatação é fornecida pelo dprint , uma alternativa extremamente rápida ao Prettier que clona todas as regras estabelecidas do Prettier 2.0.
              
              Para formatar um arquivo, use a extensão de código do Visual Studio (mais sobre isso mais adiante).deno fmt <files>
              
              Compilando e agrupando
              O Deno pode criar um pacote simples a partir da linha de comando usando deno bundle, mas também expõe uma API interna do compilador para que o usuário possa criar sua própria saída, algo que pode ser personalizado para uso na interface. No momento, esta API está marcada como instável, portanto, você precisa usar o sinalizador.--unstable
              
              Embora o Deno tenha algumas APIs compatíveis com a Web, elas não estão completas. Se você deseja compilar qualquer TypeScript de front-end que faça referência ao DOM, é necessário informar o Deno sobre esses tipos ao compilar ou agrupar. Você pode usar a opção API do compilador lib.
              
              índice . html
               <! DOCTYPE html > < html lang = "en" > < cabeça > < meta charset = "UTF-8" /> < nome da meta = "viewport" content = "width = largura do dispositivo, escala inicial = 1.0" /> < title > Documento </ title > </ head > < corpo > < h1 id = "greeter"
               
                
                    
                     
                  
                
                
                   me </ h1 > </ body > </ html > 
              teste - dom . ts
               deixe saudar : HTMLElement | null = documento . getElementById ( "greeter" ) !; // Perdoe o operador de afirmação não nula
                
                   
              
              cumprimentar . innerText = "Olá mundo!" ; 
              compilar . ts
               const [ erros , emitida ] = aguardam Deno . compile ( "test-dom.ts" , indefinido , { 
                lib : [ "dom" , "esnext" ], // inclua "deno.ns" para o namespace 
                deno outDir : "dist" , });           
              
              
              if ( erros ) { 
                console . log ( "Ocorreu um erro:" ); 
                console . erro ( erros ); } else { 
                console . log ( emitido ); // normalmente escreveríamos o arquivo }  
                 
              Abaixo está a saída do mapa de emissão resultante no terminal.
              
              { 
               dist / test - dom . js . map : "{" version ": 3," file ":" test - dom . js "," sourceRoot ":" "," sources ": [" file : /// home / david / Downloads / deno-arti ... ", 
               dist / test - dom . js : " " use strict " ; nlet greeter = document.getElementById ( "  ); ngreeter.innerText = " Olá mundo ! " ; n ... " }
              No exemplo acima, compilamos o arquivo que referencia o DOM. O uso da opção substitui qualquer opção padrão usada pelo Deno, portanto, você deve adicionar novamente e, opcionalmente, usar o espaço para nome Deno.test-dom.tslibDeno.compile()libesnextdeno.ns
              
              Tudo isso ainda é um pouco experimental, mas espero que o bundlecomando evolua para cuidar de coisas como tremer as árvores e agir mais como isso .Rollup.js
              
              Depuração
              Deno possui depuração interna, mas no momento da redação, a extensão de código do Visual Studio não a suporta. Para depurar, use manualmente o seguinte.
              
              deno run -A --inspect-brk fileToDebug.ts (Nota: use permissões mínimas para o seu módulo)
              Abra no Chrome ou Chromium. Você verá uma tela semelhante à abaixochrome://inspect
              Inspecionar com Chrome
              Clique em "inspecionar" para conectar e começar a depurar seu código
              Observação de arquivos
              O Deno possui a visualização de arquivos incorporada usando a biblioteca de notificações do Rust através da API. Deno gosta de fornecer o trabalho pesado nos bastidores com suas APIs e permitir que o usuário implemente seu código como quiser. Em vez de fornecer um sinalizador, você precisará criar sua própria implementação ou usar um módulo de terceiros.Deno.watchFs()--watch
              
              O único aspecto não trivial de criar seu próprio observador de arquivos é a devolução. A API pode acionar vários eventos em rápida sucessão e você provavelmente não deseja executar sua ação várias vezes. O usuário Caesar2011 resolveu o problema em 23 linhas de TypeScript usando .Date.now()
              
              Há também uma solução mais avançada de visualização de arquivos Deno, chamada Denon . É o equivalente a nodemon. Se você deseja observar seu espaço de trabalho em busca de alterações e executar novamente seus testes, é tão fácil quanto:
              
              teste de denon
              Plug-in do Visual Studio Code
              A melhor extensão de longe é a axetroy, disponível no Visual Studio Market Place . Após a instalação, crie um arquivo na pasta do projeto e ative a extensão por projeto..vscode/settings.json
              
              // .vscode / settings.json { "deno.enable" : true , }
              
                 
              Agora você terá acesso ao suporte completo do IntelliSense e tudo o que precisa para obter a codificação.
              
              Conclusão
              A rápida taxa de mudança no ecossistema JavaScript provou ser uma bênção mista. Pelo lado positivo, nunca houve mais ferramentas de alta qualidade disponíveis. Do lado negativo, existe um senso geral de cinismo e cansaço em torno da barragem interminável de novas estruturas e bibliotecas lançadas contra nós.
              
              O Deno remove com êxito muitas das desvantagens do desenvolvimento do JavaScript. Abaixo estão apenas alguns.
              
              Ao usar os padrões da web, a Deno prepara suas APIs para o futuro. Isso dá aos desenvolvedores a confiança de que não estão perdendo tempo aprendendo algo que em breve será obsoleto
              Ter o TypeScript além do JavaScript elimina o ônus da compilação e permite uma integração mais rígida
              Ferramentas integradas significam que não há necessidade de perder tempo procurando por algo que é fornecido imediatamente
              O gerenciamento descentralizado de pacotes libera os usuários do npm, e os módulos ECMAScript trazem um pouco de ar fresco, em comparação ao uso decrépito do CommonJS
              Embora ainda não possa substituir completamente o Node.js., o Deno já é um ambiente de programação fantástico para uso diário.
              
              LogRocket : visibilidade total em seus aplicativos da web
              Faixa de avaliação gratuita do painel LogRocket
              O LogRocket é uma solução de monitoramento de aplicativos front-end que permite reproduzir problemas como se eles tivessem acontecido no seu próprio navegador. Em vez de adivinhar por que os erros acontecem ou pedir aos usuários capturas de tela e despejos de log, o LogRocket permite reproduzir a sessão para entender rapidamente o que deu errado. Funciona perfeitamente com qualquer aplicativo, independentemente da estrutura, e possui plugins para registrar contexto adicional do Redux, Vuex e @ ngrx / store.
              
              Além de registrar ações e estado do Redux, o LogRocket registra logs do console, erros de JavaScript, rastreamentos de pilha, solicitações / respostas de rede com cabeçalhos + corpos, metadados do navegador e logs personalizados. Ele também instrui o DOM a gravar o HTML e o CSS na página, recriando vídeos perfeitos em pixels até dos aplicativos de página única mais complexos.</p>
            <p>Fonte: https://blog.logrocket.com/deno-1-0-what-you-need-to-know/</p>
          </div>
          <div class="card-footer text-muted">
            Posted on Juny 1, 2020 by
            <a href="https://blog.logrocket.com/deno-1-0-what-you-need-to-know/">David Else</a>
          </div>
        </div>
          
           <div class="card mb-4">
          <img class="card-img-top" src="https://miro.medium.com/max/1400/1*TI9aEtFcjK9oIQ2-iUJG3w.png" alt="Card image cap">
          <div class="card-body">
            <h2 class="card-title">Breve História/h2>
            <p class="card-text">Design Patterns</p>

              <p>Padrões são soluções típicas para problemas comuns no design orientado à objetos, quando uma solução é repetida várias vezes em muitos projetos, eventualmente alguém dá um nome e tenta descrever a solução em detalhes.É basicamente assim que um padrão é descoberto.

Padrões de design de software orientado a objetos foi publicado em 1995 por Erich Gamma, John Vlissides, Ralph Johnson e Richard Helm no livro “Design Patterns: Elements of Reusable Object-Oriented Software”, onde foram descritos 23 padrões que resolviam vários problemas de design orientado a objetos e se tornou um best-seller muito rapidamente. Devido ao seu nome ser muito extenso o livro foi batizado de GoF (Gang of Four).
Por que é importante sabermos patterns?

A verdade é que você pode trabalhar por anos como programador sem precisar conhecer um único padrão, muitas pessoas fazem exatamente isso, mas possivelmente elas estão implementando algum padrão sem necessariamente saber disso. Então ficamos com a pergunta “Porque é importante sabermos os design patterns?”. Vou tentar ser preciso para explicar as razões:

    Os design patterns são basicamente soluções que foram implementadas, testadas e comprovadas como eficazes para problemas comuns no design de software. Mesmo que você nunca se depare com esses problemas, conhecer padrões ainda é útil porque ensina como resolver todos os tipos de problemas usando princípios de design orientado a objetos e isso pode simplificar a forma de resolver problemas cotidianos ao desenvolver software.
    Os design patterns definem palavras comuns para citar um problema especifico e assim fica mais fácil de se comunicar.Você pode dizer: “Use singleton nesse caso” e todos os envolvidos no processo entenderão a ideia citada, não seria necessário explicar o que é um singleton se você souber o padrão e o nome.

Classificando os design patterns

Os design patterns se diferem por sua complexidade, nível de detalhe e escala de aplicabilidade para todo o sistema que está sendo projetado.

Os patterns mais básicos e de baixo nível são chamados de expressões idiomáticas, geralmente se aplicam apenas a uma única linguagem de programação.

Os design patterns mais universais e de alto nível são os padrões arquiteturais. Os desenvolvedores podem implementar esses padrões em praticamente qualquer linguagem de programação. Diferentemente de outros padrões, eles podem ser usados para projetar a arquitetura de um aplicativo inteiro.

Além disso podemos classificar todos os padrões por sua intenção ou propósito, irei tentar cobrir os três grupos citados pelo gof exemplificando os principais padrões:

    Creation Patterns (padrões criacionais) fornecem mecanismos de criação de objetos que aumentam a flexibilidade e a reutilização de código existente. (Iremos representar pela letra “C”)
    Structural patterns ( padrões estruturais) explicam como montar objetos e classes em estruturas maiores, mantendo as estruturas flexiveis e eficientes. (Iremos representar pela letra “S”)
    Behavioral patterns (padrões comportamentais) cuidam da comunicação eficaz e da atribuição de responsabilidade entre objetos. (Iremos representar pela letra “B”)</p>
          </div>
          <div class="card-footer text-muted">
            Posted on Juny 1, 2020 by
            <a href="#">Pedro Bazzo</a>
          </div>
        </div>

        <!-- Pagination -->
        <ul class="pagination justify-content-center mb-4">
          <li class="page-item">
            <a class="page-link" href="#">&larr; Inicio</a>
          </li>
          <li class="page-item disabled">
            <a class="page-link" href="#">Próximo &rarr;</a>
          </li>
        </ul>

      </div>

      <!-- Sidebar Widgets Column -->
      <div class="col-md-4">

        <!-- Categories Widget -->
        <div class="card my-4">
          <h5 class="card-header">Categorias</h5>
          <div class="card-body">
            <div class="row">
              <div class="col-lg-6">
                <ul class="list-unstyled mb-0">
                  <li>
                    <a href="https://medium.com/tableless/design-web-sem-misterios-para-iniciantes-63d9d69130d9">Web Design</a>
                  </li>
                  <li>
                    <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTML">HTML</a>
                  </li>
                  <li>
                    <a href="https://cursos.erickwendel.com.br/">Node</a>
                  </li>
                </ul>
              </div>
              <div class="col-lg-6">
                <ul class="list-unstyled mb-0">
                  <li>
                    <a href="https://www.youtube.com/channel/UCW9pyonagDWGMCy7V_Kro6g">JavaScript</a>
                  </li>
                  <li>
                    <a href="https://www.w3schools.com/w3css/">CSS</a>
                  </li>
                  <li>
                    <a href="https://www.youtube.com/channel/UCSfwM5u0Kce6Cce8_S72olg">Tutorials</a>
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </div>

        <!-- Side Widget -->
        <div class="card my-4">
          <h5 class="card-header">React</h5>
          <div class="card-body">
            <img class="card-img-top" src="data:image/png;base64,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" alt="Card image cap">
           <p> Pratique React</p>
            <p>React foi pensado desde o início para ser adotado gradualmente e você pode usar menos ou mais da biblioteca de acordo com sua necessidade. Se você quer uma amostra do React, adicionar interatividade a uma página HTML simples ou iniciar uma aplicação React complexa, os links desta seção o ajudarão no início.</p>
            <a href="https://pt-br.reactjs.org/docs/getting-started.html">Documentação</a>
          </div>
        </div>

      </div>

    </div>
    <!-- /.row -->

  </div>
  <!-- /.container -->

  <!-- Footer -->
  <footer class="py-5 bg-dark">
    <div class="container">
      <p class="m-0 text-center text-white">Copyright &copy; @pedropbazzo 2020</p>
    </div>
    <!-- /.container -->
  </footer>

  <!-- Bootstrap core JavaScript -->
  <script src="vendor/jquery/jquery.min.js"></script>
  <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

</body>

</html>
